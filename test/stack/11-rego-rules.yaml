---
apiVersion: v1
kind: ConfigMap
metadata:
  name: hdfs-regorules
  labels:
    opa.stackable.tech/bundle: "true"
data:
  hdfs.rego: |
    package hdfs

    import rego.v1

    default allow = false

    allow if {
        some acl in acls
        matches_identity(input.callerUgi.shortUserName, acl.identity)
        matches_resource(input.path, acl.resource)
        action_sufficient_for_operation(acl.action, input.operationName)
    }

    # Identity mentions the user explicitly
    matches_identity(user, identity) if {
        identity == concat("", ["user:", user])
    }

    # Identity mentions group the user is part of
    matches_identity(user, identity) if {
        some group in groups[user]
        identity == concat("", ["group:", group])
    }


    # Resource mentions the file explicitly
    matches_resource(file, resource) if {
        resource == concat("", ["hdfs:file:", file])
    }

    # Resource mentions a folder higher up the tree, which will will grant access recursively
    matches_resource(file, resource) if {
        startswith(resource, "hdfs:dir:/")
        # dirs need to have a trailing slash
        endswith(resource, "/")
        startswith(file, trim_prefix(resource, "hdfs:dir:"))
    }

    action_sufficient_for_operation(action, operation) if {
        action_hierarchy[action][_] == action_for_operation[operation]
    }


    action_hierarchy := {
        "full": ["full", "rw","ro"],
        "rw": ["rw", "ro"],
        "ro": ["ro"],
    }

    action_for_operation := {
        "getfileinfo": "ro",
        "listStatus": "ro",
        "delete": "full",
    }

    groups := {"HTTP": ["http-group"]}

    acls := [
    	{
    		"identity": "user:HTTP",
    		"action": "full",
    		"resource": "hdfs:file:/hosts",
    	},
        {
            "identity": "group:http-group",
            "action": "full",
            "resource": "hdfs:dir:/",
        },
        {
            "identity": "user:HTTP",
            "action": "full",
            "resource": "hdfs:dir:/ro/full/",
        },
    ]

    # hdfs:file:/hosts
    # hdfs:file:/hosts/andrew_*
    # hdfs:dir:/hosts/
    # kafka:topic:events
    # trino:table:tpch.sf1.customers
    # trino:schema:tpch.sf1
    # trino:catalog:tpch

  hdfs-groups.rego: |
    package hdfs_groups

    # this will return the group data in this form:
    #    "result": {
    #        "groups": [
    #            "admin",
    #            "superuser"
    #        ]
    #        ...
    groups := {g |
      raw = users_by_name[input.username].groups[_]
      g := trim(raw, "/")
    }

    # returning data in the form presented by the UIF
    users_by_name := {
        "alice": {
            "id": "af07f12c-1234-40a7-93e0-874537bdf3f5",
            "username": "alice",
            "groups": ["/superset-admin"],
            "customAttributes": {},
        },
        "bob": {
            "id": "af07f12c-2345-40a7-93e0-874537bdf3f5",
            "username": "bob",
            "groups": ["/admin"],
            "customAttributes": {},
        },
        "stackable": {
            "id": "af07f12c-3456-40a7-93e0-874537bdf3f5",
            "username": "stackable",
            "groups": ["/admin", "/superuser"],
            "customAttributes": {},
        },
    # Hadoop will use the short-name for group mappings
        "nn": {
            "id": "af07f12c-7890-40a7-93e0-874537bdf3f5",
            "username": "nn",
            "groups": ["/admin", "/superuser"],
            "customAttributes": {},
        },
    }
